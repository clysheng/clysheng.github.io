{"meta":{"title":"Harvey's blog","subtitle":"无论工作多忙，计划都要坚持","description":"再牛逼的梦想，也抵不过傻逼式的坚持","author":"Harvey","url":"http://mrhe.top"},"pages":[{"title":"tags","date":"2017-12-31T07:29:14.000Z","updated":"2017-12-31T07:42:09.473Z","comments":true,"path":"tags/index.html","permalink":"http://mrhe.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-31T07:29:31.000Z","updated":"2017-12-31T07:50:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://mrhe.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"虚拟机类加载机制","slug":"虚拟机类加载机制","date":"2020-03-08T06:26:00.000Z","updated":"2020-03-08T12:37:24.679Z","comments":true,"path":"2020/03/08/虚拟机类加载机制/","link":"","permalink":"http://mrhe.top/2020/03/08/虚拟机类加载机制/","excerpt":"","text":"一. 概述虚拟机把描述类的数据，从class文件加载到内存,并对数据进行校验，解析，初始化，最终形成可以虚拟机直接使用的java类型，就是虚拟机的类加载机制。 二. 类的加载时机类从加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括图上7个阶段 其中加载，验证，准备，初始化，卸载五个阶段的执行顺序是确定的，而解析阶段不一定，可以在初始化之后开始。 java虚拟机中没有明确规范什么时候类加载过程的第一个阶段加载，交给虚拟机具体实现来自由把握，但对于初始化阶段，严格规定了出现以下6种情况，必须立即对类进行初始化： 遇到new，getstatic，putstatic，invokestatic四条字节码指令时，如果类型没有初始化，需要先出发初始化阶段，能够生成四条java代码场景有： 使用new关键字实例化对象 读取或设置一个类型静态字段的时候 调用一个类型静态方法的时候 通过java.lang.reflect的方法对类进行反射调用的时候 初始化类发现父类没有初始化的时候，先触发父类的初始化 虚拟机启动的时候，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类，就是包含main方法的那个类 如果一个java.lang.invoke.MethodHandle实例最后解析结果为REF_getStatic,REF_invoke_putStatic,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄，如果这个方法句柄对应的类没有初始化，要先初始化这个类 JDK1.8接口加入了默认方法，如果有个接口的实现类发生了初始化，那么接口要在其之前被初始化 这六种场景中的行为称为对一个类型的主动引用，除此之外所有引用类型的方式都不会主动触发初始化，称为被动引用。 #三. 类加载的过程 加载加载是类加载的一个阶段，在这个阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证验证的目的是为了确保class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全，验证阶段大致会完成下面四个阶段的校验动作: 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这个阶段进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，为变量赋初始值，通常情况是数据类型的零值，正在为变量赋值是在初始化阶段，通过构造器实现的。 解析解析阶段是虚拟机将常量池内的符号引用替换我直接引用的过程。 初始化到了初始化阶段才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已赋过一次系统要求的初始值，而在初始化阶段，则根据程序员主观计划去初始化类变量和其它资源。初始化阶段是执行类构造器方法的过程。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://mrhe.top/categories/jvm/"}],"tags":[{"name":"java","slug":"java","permalink":"http://mrhe.top/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://mrhe.top/tags/jvm/"}]},{"title":"docker搭建redis-cluster集群","slug":"docker搭建redis-cluster集群","date":"2019-03-20T06:00:00.000Z","updated":"2020-03-08T11:46:27.911Z","comments":true,"path":"2019/03/20/docker搭建redis-cluster集群/","link":"","permalink":"http://mrhe.top/2019/03/20/docker搭建redis-cluster集群/","excerpt":"","text":"本文为阿里云环境下使用docker搭建redis-cluster集群，规划为两台机器，一台机器三个节点，分别开放7001，7002，7003，17001，17002，17003端口 ##安装docker这里不过多说，网上方案很多 ##新建docker容器映射目录在/docker/rediscluster/目录下执行1234for i in `seq 7001 7006`do mkdir -p $&#123;i&#125;/datadone ##编写docker-compose文件123456789101112131415161718192021222324252627282930313233343536373839version: &apos;3.4&apos;x-image: &amp;default-image publicisworldwide/redis-clusterx-restart: &amp;default-restart alwaysx-netmode: &amp;default-netmode hostservices: redis1: image: *default-image network_mode: host restart: *default-restart volumes: - /docker/rediscluster/7001/data:/data environment: - REDIS_PORT=7001 redis2: image: *default-image network_mode: host restart: *default-restart volumes: - /docker/rediscluster/7002/data:/data environment: - REDIS_PORT=7002 redis3: image: *default-image network_mode: host restart: *default-restart volumes: - /docker/rediscluster/7003/data:/data environment: - REDIS_PORT=7003 两台机器分别执行1docker-compose up -d ##部署cluster通过redis-trib启动集群,在其中一台机器执行1docker run --rm -it inem0o/redis-trib create --replicas 1 xxx.xxx.xxx.xxx:7001 xx.xxx.xxx.xxx:7002 xx.xxx.xxx.xxx:7003 执行前要确保两台机器需要的端口是开放的","categories":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/tags/docker/"},{"name":"redis","slug":"redis","permalink":"http://mrhe.top/tags/redis/"}]},{"title":"Mycat实现读写分离","slug":"Mycat实现读写分离(二)","date":"2019-02-20T06:45:00.000Z","updated":"2019-02-21T06:55:58.567Z","comments":true,"path":"2019/02/20/Mycat实现读写分离(二)/","link":"","permalink":"http://mrhe.top/2019/02/20/Mycat实现读写分离(二)/","excerpt":"","text":"一.前期规划在同一台服务器上测试，创建三个docker容器，两个mysql，一个mycat，具体规划如下123192.168.0.168 8066 Mycat容器192.168.0.168 3307 mysql容器(slave)192.168.0.168 3308 mysql容器(master) 二.配置server.xml参数1234&lt;user name=&quot;iwunu&quot;&gt; &lt;property name=&quot;password&quot;&gt;iwunu&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;NBIOT&lt;/property&gt;&lt;/user&gt; 参数 说明 user 用户配置节点 name 连接Mycat的用户名 password 连接Mycat的密码 schemas 数据库名，会与schema.xml中的配置关联，多个用逗号隔开，例如需要这个用户管理两个数据库iwunu1,iwunu2 三.配置schema.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;schema name=&quot;NBIOT&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;1000&quot; dataNode=&quot;dn1&quot;&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;iwunulog&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.0.168:3308&quot; user=&quot;root&quot; password=&quot;Iwunu_20180212&quot; &gt; &lt;readHost host=&quot;hostS2&quot; url=&quot;192.168.0.168:3307&quot; user=&quot;root&quot; password=&quot;Iwunu_20180212&quot; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; 参数 说明 schema 数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应 dataNode 分片信息，也就是分库相关配置 dataHost 物理数据库，真正存储数据的数据库 每个节点的属性逐一说明： schema: 属性 说明 name 逻辑数据库名，与server.xml中的schema对应 checkSQLschema 数据库前缀相关设置，建议看文档，这里暂时设为false sqlMaxLimit select 时默认的limit，避免查询全表 table: 属性 说明 name 表名，物理数据库中表名 dataNode 表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name primaryKey 主键字段名，自动生成主键时需要设置 autoIncrement 是否自增 rule 分片规则名 dataNode: 属性 说明 name 节点名，与table中dataNode对应 dataNode 物理数据库名，与datahost中name对应 database 物理数据库中数据库名 dataHost: 属性 说明 name 物理数据库名，与dataNode中dataHost对应 balance 均衡负载的方式 writeType 写入方式 dbType 数据库类型 heartbeat 心跳检测语句，注意语句结尾的分号要加 四.配置Mysql需要注意的是Mysql主从分离只是在读的时候做了处理，写入数据的时候，只会写入到writehost，Mycat本身没有主从复制功能，需要单独实现mysql的主从复制功能","categories":[{"name":"Mycat","slug":"Mycat","permalink":"http://mrhe.top/categories/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"http://mrhe.top/tags/Mycat/"}]},{"title":"Mycat概述","slug":"Mycat概述(一)","date":"2019-02-20T06:45:00.000Z","updated":"2019-02-21T06:33:53.940Z","comments":true,"path":"2019/02/20/Mycat概述(一)/","link":"","permalink":"http://mrhe.top/2019/02/20/Mycat概述(一)/","excerpt":"","text":"Mycat是什么Mycat是一个开源的分布式数据库系统，是一个实现了MySQL协议的Server,前端用户可以把它当做一个数据库代理，可以通过MySQL工具和命令行访问，也可以用jdbc协议与大多数主流数据库服务器通信。Mycat没用存储引擎，所以并不是完全意义的分布式数据库系统，一般称之为数据库中间件，介于数据库和应用之间，进行中间服务,如下图所示 Mycat可以做什么Mycat核心功能就是分表分库，将一个大表水平切分N个小表，存储在后端MySQL服务器里活其它数据库里。Mycat发展到现在已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL，SQLServer，Oracle，DB2，PostgreSQL等主流数据库，也支持MongoDB这种NoSQL方式的存储，无论哪种方式存储，在Mycat里，都是一个传统的数据库表，支持标准的SQL语句进行数据操作。Mycat 是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多 租户应用开发、云平台基础设施、让你的架构具备很强的适应性和灵活性，借助于即将发布的Mycat智能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表映射到不同存储引擎上，而整个应用的代码一行也不用改变。 Mycat原理Mycat会拦截用户发送过来的SQL语句，然后对语句进行一些特定的分析，如分片分析、路由分析、读写分离分析、缓存分析等，然后将SQL语句发送给后端真实的数据库，并将返回结果适当处理，最终再返回给用户。 上述图片里，Orders 表被分为三个分片 datanode(简称 dn)，这三个分片是分布在两台 MySQL Server 上 (DataHost)，即 datanode=database@datahost 方式，因此你可以用一台到 N 台服务器来分片，分片规则为 (sharding rule)典型的字符串枚举分片规则，一个规则的定义是分片字段(sharding column)+分片函数(rule function)，这里的分片字段为prov而分片函数为字符串枚举方式。当Mycat收到一个SQL时，会先解析这个SQL，查找涉及到的表，然后看此表的定义，如果有分片规则， 则获取到 SQL 里分片字段的值，并匹配分片函数，得到该SQL对应的分片列表，然后将SQL发往这些分片去执行，最后收集和处理所有分片返回的结果数据，并输出到客户端。以 select from Orders where prov=?语句为 例，查到 prov=wuhan，按照分片函数，wuhan返回dn1，于是SQL就发给了MySQL1，去取DB1上的查询结果，并返回给用户。如果上述 SQL 改为 select from Orders where prov in (‘wuhan’,‘beijing’)，那么，SQL 就会发给MySQL1与MySQL2去执行，然后结果集合并后输出给用户。 Mycat应用场景Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景: 单纯的读写分离，此时配置最为简单，支持读写分离，主从切换; 分表分库，对于超过1000 万的表进行分片，最大支持 1000亿的单表分片; 多租户应用，每个应用一个库，但应用程序只连接 Mycat，从而不改造程序本身，实现多租户化; 报表系统，借助于 Mycat 的分表能力，处理大规模报表的统计; 替代Hbase，分析大数据; 作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时 Mycat 可能是最简单有效的选择。","categories":[{"name":"Mycat","slug":"Mycat","permalink":"http://mrhe.top/categories/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"http://mrhe.top/tags/Mycat/"}]},{"title":"springboot的jar包在linux下启动方式","slug":"springboot的jar文件包在linux下启动方式","date":"2018-12-25T12:05:00.000Z","updated":"2018-12-25T12:15:41.420Z","comments":true,"path":"2018/12/25/springboot的jar文件包在linux下启动方式/","link":"","permalink":"http://mrhe.top/2018/12/25/springboot的jar文件包在linux下启动方式/","excerpt":"","text":"方式一1java -jar XXX.jar 特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出 方式二1java -jar XXX.jar &amp; &amp;代表在后台运行。 特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。 方式三1nohup java -jar XXX.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 方式四1nohup java -jar XXX.jar &gt;temp.txt &amp; &gt;temp.txt输出内容到指定文件中而不是答应道屏幕上","categories":[{"name":"springboot","slug":"springboot","permalink":"http://mrhe.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://mrhe.top/tags/springboot/"}]},{"title":"记mqtt碰到的几个问题","slug":"记mqtt的几个坑","date":"2018-12-25T03:53:00.000Z","updated":"2018-12-25T07:00:26.167Z","comments":true,"path":"2018/12/25/记mqtt的几个坑/","link":"","permalink":"http://mrhe.top/2018/12/25/记mqtt的几个坑/","excerpt":"","text":"碰到的两个问题mqtt断线的问题一段时间使用发现mqtt会断线，可以在callbakurl中做从重连 ###clientid重复 在一台服务器上启动了两个mqtt应用，因为clientId设置的是固定的值，所以两个应用的clientId会互相挤掉线，解决办法就是就clientId设置不同的值。 另外一种情况是断线重连的时候每次都是new了一个新的mqttclient对象，导致与之前的mqtt对象的clientId重复了，解决办法就是就是将mqttclient对象设置为单例模式。","categories":[{"name":"工作","slug":"工作","permalink":"http://mrhe.top/categories/工作/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://mrhe.top/tags/工作/"},{"name":"mqtt","slug":"mqtt","permalink":"http://mrhe.top/tags/mqtt/"}]},{"title":"vim学习笔记(一)","slug":"vim编辑器学习笔记","date":"2018-12-21T07:00:00.000Z","updated":"2020-03-08T06:25:29.112Z","comments":true,"path":"2018/12/21/vim编辑器学习笔记/","link":"","permalink":"http://mrhe.top/2018/12/21/vim编辑器学习笔记/","excerpt":"","text":"vim下两种模式 Normal启动vim后，默认在Normal模式下，点击i进入 Insert在该模式下可以输入任何内容，退出该模式按ESC，返回到Normal模式 Normal模式下常用指令 x -&gt; 删除当前光标所在的一个字符 i -&gt; 进入Insert模式 :wq -&gt; 存盘+退出，:w存盘，:q退出 ，:w后可以跟文件名 dd -&gt; 删除当前行，并把删除的行存到剪贴板里 p -&gt; 粘贴 yy -&gt; 拷贝当前行 hjkl -&gt; 对应⬅️⤵️⤴️➡️ u -&gt; 撤回 Normal模式下进阶指令1.各种插入模式 a -&gt; 在光标后面插入 o -&gt; 在当前行后插入一个新行 O -&gt; 在当前行前插入一个新行 cw -&gt; 替换从光标所在位置后到一个单词结尾的字符 2.简单移动光标 0 -&gt; 数字零到行头 ^ -&gt; 到本行第一个不是blank字符的位置(blank字符就是空格，tab，换行，回车等) $ -&gt; 到本行行尾 g_ -&gt; 到本行最后一个不是blank字符的位置 /pattern -&gt; 搜索pattern的字符串，如果搜索出来多个匹配的，按n键到下一个 3.组合指令 2dd -&gt; 删除两行 3p -&gt; 粘贴三次 N -&gt; 重复某个命令N次，先摁下N输入100ivim,再摁下esc，会写下100个vim . -&gt; 重复上个命令 3.-&gt; 重复3次vim，不是300 4.更强大的光标移动 gg -&gt; 到第一行 G -&gt; 到最后一行 NG -&gt; 到第N行 按单词移动 w -&gt; 到下一个单词开头 e -&gt; 到下一个单词结尾 ###5.替换 ：1,$ s/old/new/g -&gt;把整个文件中old的每次出现改为new","categories":[{"name":"工具","slug":"工具","permalink":"http://mrhe.top/categories/工具/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://mrhe.top/tags/vim/"},{"name":"工具","slug":"工具","permalink":"http://mrhe.top/tags/工具/"}]},{"title":"docker常用操作","slug":"使用docker快速搭建一个halo博客系统","date":"2018-05-22T16:00:00.000Z","updated":"2019-02-26T09:59:27.541Z","comments":true,"path":"2018/05/23/使用docker快速搭建一个halo博客系统/","link":"","permalink":"http://mrhe.top/2018/05/23/使用docker快速搭建一个halo博客系统/","excerpt":"","text":"1.将对容器的修改提交到镜像先启动一个镜像1docker run -t -i ubuntu:14.04 /bin/bash 当退出容器后，容器停止运行，但是容器还在，可以提交对容器做出的修改，并新建一个镜像12docker ps #查看容器iddocker commit 容器id 新的镜像名字:tag 2.宿主机和容器之间共享数据在运行docker run命令时，可以通过-v将宿主机的卷挂载到容器中若想将宿主机的/share目录下工作目录与容器共享，可以执行以下命令，执行命令前先进入到share目录下 12docker run -ti -v &quot;$PWD&quot;:/share unbuntu:14.04 /bin/bash 3.宿主机器与容器之间互相复制数据 容器复制到宿主 1docker cp 容器名字:文件路径 宿主机器路径 宿主复制到容器 1docker cp 宿主机器路径 容器名字:文件路径 如果两个容器之间复制，可以先把文件复制到宿主机器，再从宿主机器复制到另一个容器,重复上面两个步骤 4.删除容器删除指定容器1docker rm 容器id 删除所有容器1docker rm $(docker ps -aq)","categories":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/tags/docker/"}]},{"title":"docker常用操作","slug":"docker常用操作","date":"2018-05-22T16:00:00.000Z","updated":"2019-02-20T06:14:43.626Z","comments":true,"path":"2018/05/23/docker常用操作/","link":"","permalink":"http://mrhe.top/2018/05/23/docker常用操作/","excerpt":"","text":"1.将对容器的修改提交到镜像先启动一个镜像1docker run -t -i ubuntu:14.04 /bin/bash 当退出容器后，容器停止运行，但是容器还在，可以提交对容器做出的修改，并新建一个镜像12docker ps #查看容器iddocker commit 容器id 新的镜像名字:tag 2.宿主机和容器之间共享数据在运行docker run命令时，可以通过-v将宿主机的卷挂载到容器中若想将宿主机的/share目录下工作目录与容器共享，可以执行以下命令，执行命令前先进入到share目录下 12docker run -ti -v &quot;$PWD&quot;:/share unbuntu:14.04 /bin/bash 3.宿主机器与容器之间互相复制数据 容器复制到宿主 1docker cp 容器名字:文件路径 宿主机器路径 宿主复制到容器 1docker cp 宿主机器路径 容器名字:文件路径 如果两个容器之间复制，可以先把文件复制到宿主机器，再从宿主机器复制到另一个容器,重复上面两个步骤 4.删除容器删除指定容器1docker rm 容器id 删除所有容器1docker rm $(docker ps -aq)","categories":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/tags/docker/"}]},{"title":"EffectiveJava学习笔记","slug":"Effective java学习笔记","date":"2018-04-17T01:00:00.000Z","updated":"2020-03-08T08:50:54.967Z","comments":true,"path":"2018/04/17/Effective java学习笔记/","link":"","permalink":"http://mrhe.top/2018/04/17/Effective java学习笔记/","excerpt":"","text":"一.创建和销毁对象1.考虑用静态方工厂方法代替构造器优势： 静态工厂方法有名称，更易于阅读 不必每次调用的时候都创建一个新对象 可以返回原返回类型的任何子类型的对象,更灵活 创建参数化类型实例的时候，他们使代码边的更加简洁 缺点： 类如果不含公有或者受保护的构造器，就不能被子类化 他们于其它静态方法实际上没有任何区别 2.服务提供者框架三个重要组件： 服务接口(Service Interface) 提供者注册API(Provider Registration API) 服务访问API(Service Access API) 可选，服务提供者接口(Servcie Provider Interface) 3.遇到多个构造器参数的时候要考虑用构造器 考虑用重叠构造器 1234567891011121314151617181920public class UserDemo1 &#123; private final String name ; private final String address ; private final int age ; private final String phone ; public UserDemo1(String name,String address)&#123; this(name,address,0) ; &#125; public UserDemo1(String name,String address,int age)&#123; this(name,address,0,&quot;&quot;) ; &#125; public UserDemo1(String name,String address,int age,String phone)&#123; this.name = name ; this.address = address ; this.age = age ; this.phone = phone ; &#125;&#125; 缺点就是当参数过多的时候，不容易阅读，很难理解参数的意思，甚至容易搞反参数。 JavaBeans的模式，通过set方法来设置每个必要参数 12345678910111213141516171819202122public class UserDemo2 &#123; private String name ; private String address ; private int age ; private String phone ; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public int getAge() &#123; return age; &#125; public String getPhone() &#123; return phone; &#125;&#125; 优点是代码易读，缺点是阻止了把类做成不可边的可能，多线程情况不能保证对象的一致状态，需要付出额外的努力保证线程安全 Builder模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class User &#123; private final String name ; private final String address ; private final int age ; private final String phone ; public static class Builder&#123; private final String name ; private final String phone ; private String address=&quot;sz&quot; ; private int age=18 ; public Builder(String name,String phone)&#123; this.name = name ; this.phone = phone ; &#125; public Builder age(int val)&#123; age = val ; return this ; &#125; public Builder address(String val)&#123; address = val ; return this ; &#125; public User bulid()&#123; return new User(this) ; &#125; &#125; private User(Builder builder)&#123; name = builder.name ; phone = builder.phone ; address = builder.address ; age = builder.age ; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &quot;, phone=&apos;&quot; + phone + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; public static void main(String[] args)&#123; User user = new User.Builder(&quot;harvey&quot;,&quot;13689568213&quot;).bulid() ; System.out.println(user); user = new User.Builder(&quot;harvey&quot;,&quot;13689568213&quot;).age(20).bulid() ; System.out.println(user); &#125;&#125; 既保留了重叠构造器的安全性，也保证了javabean的易读性 简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类的时候，builder模式就是中不错的选择，特别是当大多数参数是可选择的时候，但是它使用起来较为麻烦，某些十分注重性能的情况下，可能就会有问题。 4.通过私有构造器强化不可实例化的能力当我们设计了一个工具类，实例化对它没有意义，但是在缺少显式构造器的情况下，编译器会自动提供一个默认的，无参缺省的构造器，我们可以为该类添加一个显式的私有的构造方法，防止被其他类实例化。 5.消除过期的对象引用","categories":[{"name":"java","slug":"java","permalink":"http://mrhe.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://mrhe.top/tags/java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://mrhe.top/tags/学习笔记/"}]},{"title":"精力管理","slug":"精力管理","date":"2018-01-16T07:00:00.000Z","updated":"2018-02-28T08:29:04.259Z","comments":true,"path":"2018/01/16/精力管理/","link":"","permalink":"http://mrhe.top/2018/01/16/精力管理/","excerpt":"","text":"精力管理模式 精力管理的日常模式：支出和补充 精力管理的压力模式：储备和衰竭 精力管理的压力模式：透支和修复 精力管理四原则精力金字塔：精力管理四要素 身体层面的精力以数量为计可以通过呼吸，饮食，运动和睡眠等方式调节 情感层面的精力以质量为计主要包括对自我的认知与接纳，与他人的亲密互动和常规的人际交往 思想层面的精力以强度来衡量即持续集中注意力的能力，主要变现为创造力，专注力，现实乐观主义和大脑的可缩性 精神层面的精力以重量来衡量它是一个人最深层的价值观，不受外界影响，主要表现为富有责任意识和奉献精神 想要全情投入，各层面的力量，耐力，灵活性和弹力都不可或缺。 钟摆式运动，周期性补充精力 精力过度使用会导致消耗 精力使用不足会产生闲置 学会有规律的消耗和补充要想精力充沛，既要努力工作，也要放肆玩耍 突破舒适区，提高承受力要想突破自己，必须强迫自己突破舒适区，像运动员一样系统训练自己，突破极限，在恢复过程中成长 养成习惯模式，做出真正改变精力管理的理论和原理学完后，还需要展开实践活动，逐步建立适合自己的精力管理模式，并将其固化下来形成程序化的习惯模式，这是关情投入和保持高效能的关键 精力管理三步骤 确定目标 面对显示 采取行动 深呼吸训练方法深呼吸可以帮助我们放松，补充精力，缓解压力，具体训练方法如下： 保证全身舒适，用鼻子呼气，直到腹部鼓起，把手放到腹部 用嘴慢慢吸气，让腹部恢复正常，呼气和吸气的时间保持一致 重复上述动作 当腹部吸满气后，再用肺部吸气，直至感觉肺部气抵达肩部 用肺部呼吸，让空气抵达胸腔，提高肺活量，加倍发松 注意：如果练习赶到头晕，请先恢复到平时呼吸，当身体状况好转后，再重新练习，但要缩短练习时间 火呼吸训练方法火呼吸是瑜伽里的一种训练方法，是通过鼻子进行简单快速，有力的呼吸，可以排除毒素，增加肺活量，增加活力，强化对抗压力系统和增强身体耐力等，具体训练方法如下： 确保你的脊柱直立，嘴巴闭合，通过鼻子快速的呼吸，呼气量和呼吸量大致均等 吸气且胸部上提，保持住，呼气量并尽量吐干净肺部空气 开始学的时候，慢慢的做，熟练后，你可以加快速度，直到大约每分钟120-180 注意听你呼吸的声音，想象你成为一台爬山的蒸汽机配音 继续火呼吸，快速呼吸，吸气和呼气之间有停顿，保持双肩放松，脸部放松，让自己在不紧张的状态中做火呼吸。保持你的脊柱直立，但不要僵硬。 不要通过你的嘴吸气，呼气，如果你开始感觉上气不接下气了，马上停下来，通过鼻子简单地做几次深长缓慢的呼吸，直到准备好了，再重新开始 火呼吸是一种连续的呼吸，吸气或呼吸时都不要停顿和屏息。即使它有很多次的吸气和呼气，但保持连贯，从开始到停止，感觉仅是一次呼吸一样","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/tags/读书笔记/"}]},{"title":"CompletableFuture组合式异步编程","slug":"CompletableFuture组合式异步编程","date":"2018-01-10T13:00:00.000Z","updated":"2019-02-20T09:16:59.258Z","comments":true,"path":"2018/01/10/CompletableFuture组合式异步编程/","link":"","permalink":"http://mrhe.top/2018/01/10/CompletableFuture组合式异步编程/","excerpt":"","text":"组合式编程的优势 不需要为等待某些服务的响应阻塞应用的运行，充分的利用cpu，通过并行处理，从而最大化程序的吞吐量。 使用CompletableFuture构建异步应用通过一个例子来描述： 背景创建一个名为最佳价格查询器的应用，它会查询多个在线商店，依据给定的产品和服务找出最低价格。 通过代码描述同步和异步的实现区别同步的实现方式123456789101112131415161718192021222324252627282930public class Shop &#123; private Random random = new Random() ; public double getPrice(String product)&#123; return calculatePrice(product) ; &#125; /** * 模拟查询延迟 */ public static void delay() &#123; try &#123; Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 随机返回一个价格 * @param product * @return */ private double calculatePrice(String product) &#123; delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1); &#125; &#125; 每次查询需要1s，如果同时查询多个商店价格，每一个都要等前一个查询完毕才能执行，耗时过长，而且浪费cpu性能。 异步的实现123456789101112131415161718192021222324252627282930313233343536public class ShopSync &#123; private Random random = new Random() ; /** * 创建异步计算对象 * @param product * @return */ public Future&lt;Double&gt; getPriceAsync(String product) &#123; CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread( () -&gt; &#123; double price = calculatePrice(product); futurePrice.complete(price); &#125;).start(); return futurePrice; &#125; /** * 模拟查询延迟 */ public static void delay() &#123; try &#123; Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 随机返回一个价格 * @param product * @return */ private double calculatePrice(String product) &#123; delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1); &#125;&#125; 创建了一个代表异步计算的CompletableFuture实例，计算完成时包含计算结果，它创建了另外一个线程去执行计算，而实时返回一个Future实例，但最终结果计算出来，可以通过get方法得到最终结果。 这样做的优势是，当第一家商店的价格未计算出来之前，可以继续查询其它商店价格，应用不会被阻塞。 异常处理如果价格计算过程中产生了错误，会是一个很糟糕的结果，因为提示错误的异常会被限制在试图计算商品价格的当前范围内，最终会杀死该线程，导致等待get方法返回结果的的客户端永久地被阻塞。如何避免呢，实现如下： 1234567891011121314public Future&lt;Double&gt; getPriceAsync(String product)&#123; CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread( () -&gt; &#123; try&#123; double price = calculatePrice(product); futurePrice.complete(price); &#125;catch (Exception ex)&#123; futurePrice.completeExceptionally(ex) ; &#125; &#125; ).start(); ; return futurePrice ;&#125; 通过这种方式线程内部会抛出一个Exception异常，客户端不需要一直阻塞下去了，而是得到抛出异常消息。 使用工厂方法supplyAsync创建CompletableFuture123public Future&lt;Double&gt; getPriceAsync(String product) &#123; return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product)); &#125; 提供了和上面异常处理例子同样的错误管理机制 新背景以异步的方式查询多个商店，避免被单一的请求所阻塞，由此提升价格查询器的性能和吞吐量。 代码重构首先提供一个商家列表 1List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;bjshop&quot;),new Shop(&quot;szshop&quot;),new Shop(&quot;gzshop&quot;)) ; 查询所有商品价格，返回一个List列表 采用顺序查询的方式,以stream流的方式实现 123456789public static List&lt;String&gt; getPrices(String product)&#123; List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;bjshop&quot;),new Shop(&quot;szshop&quot;),new Shop(&quot;gzshop&quot;), new Shop(&quot;cqshop&quot;),new Shop(&quot;hzshop&quot;),new Shop(&quot;njshop&quot;),new Shop(&quot;wqshop&quot;),new Shop(&quot;syshop&quot;) ,new Shop(&quot;zzshop&quot;),new Shop(&quot;whshop&quot;),new Shop(&quot;jlshop&quot;) ) ; return shops.stream().map( shop-&gt;String.format(&quot;%s price is %.2f&quot;,shop.getProduct(),shop.getPrice(product)) ).collect(toList()) ; &#125; 验证该方式的执行性能 1234long start = System.nanoTime(); System.out.println(getPrices(&quot;myPhone27S&quot;)); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(&quot;Done in &quot; + duration + &quot; msecs&quot;); 12[bjshop price is 132.83, szshop price is 217.36, gzshop price is 189.29, cqshop price is 202.46, hzshop price is 124.39, njshop price is 170.00, wqshop price is 207.80, syshop price is 127.27, zzshop price is 140.72, whshop price is 145.39, jlshop price is 148.55]Done in 11161 msecs 采用并行流的方式任然进行该操作 123456789public static List&lt;String&gt; getPrices(String product)&#123; List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;bjshop&quot;),new Shop(&quot;szshop&quot;),new Shop(&quot;gzshop&quot;), new Shop(&quot;cqshop&quot;),new Shop(&quot;hzshop&quot;),new Shop(&quot;njshop&quot;),new Shop(&quot;wqshop&quot;),new Shop(&quot;syshop&quot;) ,new Shop(&quot;zzshop&quot;),new Shop(&quot;whshop&quot;),new Shop(&quot;jlshop&quot;) ) ; return shops.parallelStream().map( shop-&gt;String.format(&quot;%s price is %.2f&quot;,shop.getProduct(),shop.getPrice(product)) ).collect(toList()) ; &#125; 12[bjshop price is 172.67, szshop price is 130.66, gzshop price is 128.48, cqshop price is 187.36, hzshop price is 151.71, njshop price is 227.09, wqshop price is 151.64, syshop price is 201.61, zzshop price is 204.35, whshop price is 141.16, jlshop price is 173.75]Done in 2127 msecs 采用CompletableFuture的方式任然执行该操作 123456789101112public static List&lt;String&gt; getPrices(String product)&#123; List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;bjshop&quot;),new Shop(&quot;szshop&quot;),new Shop(&quot;gzshop&quot;), new Shop(&quot;cqshop&quot;),new Shop(&quot;hzshop&quot;),new Shop(&quot;njshop&quot;),new Shop(&quot;wqshop&quot;),new Shop(&quot;syshop&quot;) ,new Shop(&quot;zzshop&quot;),new Shop(&quot;whshop&quot;),new Shop(&quot;jlshop&quot;) ) ; List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream().map( shop -&gt; CompletableFuture.supplyAsync( ()-&gt;shop.getProduct()+&quot; price is&quot;+shop.getPrice(product) ) ).collect(toList()) ; return priceFutures.stream().map(CompletableFuture&lt;String&gt;::join).collect(toList()) ; &#125; 12[bjshop price is227.95307135502128, szshop price is209.0834114771096, gzshop price is180.0509393450812, cqshop price is148.94408809816616, hzshop price is185.99930958873858, njshop price is209.2247143369758, wqshop price is219.53671202996978, syshop price is229.10979442419102, zzshop price is150.8647592512694, whshop price is128.58930830999253, jlshop price is183.3010472086476]Done in 2097 msecs 这个地方采用两个stream,主要是考虑操作之前的延迟特性，单一的流水线，发向不通商家的请求只能以同步和顺序执行的方式才会成功 小结通过上述三种方式，我们发现，顺训流最慢，但是并行流和CompletableFuture的方式并没有相差很多，主要原因是他们内部是同样通用的线程池，默认使用固定数目的线程，具体线程数可以采用 1Runtime. getRuntime().availableProcessors() 查看，CompletableFuture允许对执行器Executor进行配置，尤其是线程池大小，让它以更适合应用需求的方式进行配置， 继续重构这次我们使用定制的执行器,继续执行价格查询器的例子 1234567891011121314151617181920public static List&lt;String&gt; getPrices(String product)&#123; List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;bjshop&quot;),new Shop(&quot;szshop&quot;),new Shop(&quot;gzshop&quot;), new Shop(&quot;cqshop&quot;),new Shop(&quot;hzshop&quot;),new Shop(&quot;njshop&quot;),new Shop(&quot;wqshop&quot;),new Shop(&quot;syshop&quot;) ,new Shop(&quot;zzshop&quot;),new Shop(&quot;whshop&quot;),new Shop(&quot;jlshop&quot;) ) ; Executor executor = Executors.newFixedThreadPool(Math.min(shops.size(), 100), new ThreadFactory() &#123; public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); return t; &#125; &#125;); List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream().map( shop -&gt; CompletableFuture.supplyAsync( ()-&gt;shop.getProduct()+&quot; price is&quot;+shop.getPrice(product),executor ) ).collect(toList()) ; return priceFutures.stream().map(CompletableFuture&lt;String&gt;::join).collect(toList()) ; &#125; 12[bjshop price is195.2661437963214, szshop price is227.33733741114568, gzshop price is182.76554778672724, cqshop price is217.15629799864445, hzshop price is211.64835186412643, njshop price is203.95503485334427, wqshop price is209.7508691664398, syshop price is165.41938531709016, zzshop price is225.43285716654617, whshop price is144.96966191158535, jlshop price is206.97255470003094]Done in 1084 msecs 这次我们发现速度提升了，需要注意的是我们创建了一个由守护线程构成的线程池，程序图退出时它会被回收 如何确定执行器线程数目 《Java并发编程实战》一书中，Brian Goetz和合著者们为线程池大小的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大小与处理器的利用率之比可以使用下面的公式进行估算: Nthreads = NCPU UCPU (1 + W/C)其中:❑NCPU是处理器的核的数目，可以通过Runtime.getRuntime().availableProce-ssors()得到❑UCPU是期望的CPU利用率(该值应该介于0和1之间)❑W/C是等待时间与计算时间的比率 使用流还是CompletableFuture 如果进行的是计算密集型操作，并且没用I/O，那么推荐使用Stream接口 如果并行的工作单元还涉及等待I/O操作那么使用CompletableFuture接口灵活性","categories":[{"name":"java","slug":"java","permalink":"http://mrhe.top/categories/java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/tags/java8/"}]},{"title":"如何阅读一本书","slug":"如何阅读一本书","date":"2018-01-10T13:00:00.000Z","updated":"2018-01-18T12:13:13.269Z","comments":true,"path":"2018/01/10/如何阅读一本书/","link":"","permalink":"http://mrhe.top/2018/01/10/如何阅读一本书/","excerpt":"","text":"读书的四层境界 基础阅读快速浏览，不管能不能读懂，知道在说什么就行 检视阅读用最少的时间了解书在说什么，书的结构，包含部分，分类，以及作者意图分为两种： 有系统的略读或粗读最少的时间找到这本书的主题或思想线索，包括书名，标题，序言，目录，索引，然后从目录里挑选一些跟主题息息相关的章节来看，然后打开书随便看一下，或者挑一些阅读下 粗浅的阅读重点在于不停顿，哪怕读到看不懂的地方也不要停下来查资料，直接忽略掉，重点放在自己能看懂的地方，哪怕最终只读懂了书里面一小部分，但是没有关系，起码已经读懂了这些，享受阅读的乐趣是学会的前提 分析阅读把一本书看透，嚼烂和消化书中内容 主题阅读读的不是书而是主题，同时阅读某个主题的多本书 阅读的时候要提出四个基本的问题 整体来看这本书在说什么 作者细节上说了什么 说的有道理吗，是部分还是全部 这本书和你有关系吗 分析阅读分\b类阅读之前一定要知道自己在读的是哪一类书，学会如何分类，可以简单把书分为小说类和论说类，或者理论性作品刚和实用型作品 \b\b透视一本书 寻找书的骨架 使用\b单一的句子，或最多几句话来叙述整本书的内容 将书中重要的篇章列举出来，并能说明他们是如何按照一定的顺序组成一个架构的 找出作者要问的问题或者要解决的问题 找出重要的单字，并透过他们与作者达成共识 将一本书重要的句子圈出来，找出其中主旨 从相关的关联中，设法架构出一本书的基础论述 找出作者解答 在评论之前一定能肯定的说我了解了 不同意作者观点要理性表达自己意见，不辩驳，不争论 尊重知识和个人观点，做任何判断前，要找到理论依据 如何阅读各种类型书籍如何阅读实用型书 检查作者是否提出了合理可执行，并且效果可检查的方法是分辨是否是实用类书籍的一个方法。 实际问题只能靠行动来解决，看完不行动，那看的就是鸡汤 如何阅读想象文学 不要抗拒想象文学带给你的影响力 不要去找共识，主旨和论述 如何阅读故事书(小说) 快速并且全心全意的读 不要太在意暂时的障碍，继续读下去，自然会柳暗花明 如何阅读史书和戏剧 主动，集中注意力的阅读 \b运用更多的想象力 最好一口气读完 如何阅读抒情诗 一口气读完 重复，大声读出来 了解一首诗最好的方式就是一遍遍的去读它 如何阅读历史书 可以抱着怀疑的态度 明白真正发生过什么 分析这些历史对现在和未来的意义 如何阅读哲学书 积极主动的思考 像哲学家一样论证你的观点 主题阅读的五个步骤 找到相关章节 构建你自己的术语体系 理清需要解答的问题 界定和确认议题 分析和讨论 主题阅读的两个要点 保持客观立场 有效使用主题工具书","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/tags/读书笔记/"}]},{"title":"摘抄","slug":"摘抄","date":"2018-01-10T13:00:00.000Z","updated":"2019-02-20T07:50:00.324Z","comments":true,"path":"2018/01/10/摘抄/","link":"","permalink":"http://mrhe.top/2018/01/10/摘抄/","excerpt":"","text":"关于反思我们在进行反思的过程中，要注意三点: 及时反思，还原事件细节，可用纸笔完成 思考时间的”反应链”，即他的开始、发展、转折和结束，它背后的动因、阻力和关键节点。 关注发生的意外事件，思考自己是否存在偏见，克服思维惰性。","categories":[{"name":"摘抄","slug":"摘抄","permalink":"http://mrhe.top/categories/摘抄/"}],"tags":[{"name":"摘抄","slug":"摘抄","permalink":"http://mrhe.top/tags/摘抄/"}]},{"title":"Optional","slug":"java8 Optional.1","date":"2018-01-09T01:30:00.000Z","updated":"2019-02-27T02:19:28.719Z","comments":true,"path":"2018/01/09/java8 Optional.1/","link":"","permalink":"http://mrhe.top/2018/01/09/java8 Optional.1/","excerpt":"","text":"null引发的问题null最常见带来的问题就是NullPointerException，即使在我们认为可能出现null的地方加上if语句判断，任然会频发的和它打交道，而且还会代码出现很多的if嵌套，被它的概念提出者Tony Hoare称之为价值百万的失误 Optional的作用能非常清晰地界定出变量值的缺失是结构上的问题，还是你算法上的缺陷，抑或是你数据中的问题。另外，我们还想特别强调，引入Optional 类的意图并非要消除每一个null引用。与此相反，它的目标是帮助你更好地设计出普适的API， 让程序员看到方法签名，就能了解它是否接受一个Optional的值。这种强制会让你更积极地将 变量从Optional中解包出来，直面缺失的变量值。 如何使用创建Optional对象声明一个空的Optional1Optional&lt;Car&gt; car = Optional.empty() ; 依据一个非空值创建Optional12Car car = null ;Optional&lt;Car&gt; carOpt = Optional.of(car) ; 如果car是一个空值，这段代码会立即抛出NullPointerException，而不是等到试图访问car属性的时候 可接受null的Optional12Car car = null ;Optional&lt;Car&gt; carOpt = Optional.ofNullable(car) ; 如果car是空那么carOpt就是一个空对象，获取对象中的值的时候依然会抛出异常 一点注意Optional在设计的时候没有考虑做为类的字段使用，所以它\b并未实现序列化接口，所以某些要求序列的库或框架中使用Optional有可能会引发应用故障\b 常用API 方法 描述 empty 返回一个空的 Optional 实例 flatMap 如果值存在，就对该值执行提供的 mapping 函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象 get 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常 ifPresent 如果值存在，就执行使用该值的方法调用，否则什么也不做 isPresent 如果值存在就返回 true，否则返回 false map 如果值存在，就对该值执行提供的 mapping 函数调用 of 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常 ofNullable 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象 orElse 如果有值则将其返回，否则返回一个默认值 orElseGet 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 orElseThrow 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 实战例子返回一个正整数，如果小于0或者不存在则返回0123456789101112131415Properties properties = new Properties() ;properties.put(&quot;a&quot;,1) ;properties.put(&quot;b&quot;,-5) ;properties.put(&quot;c&quot;,1) ; public int getValueOptional(Properties properties,String name)&#123; return Optional.ofNullable(properties.getProperty(name)).flatMap(OptionalTest::stringToInt).filter(i -&gt; i&gt;0).orElse(0) ;&#125;public static Optional&lt;Integer&gt; stringToInt(String s) &#123; try &#123; return Optional.of(Integer.parseInt(s)); &#125; catch (NumberFormatException e) &#123; return Optional.empty(); &#125;&#125; 通过这个例子可以看出，Optional加入丰富了\b\b语意，减少了之前很多不必要的if判断，代码更简洁直观","categories":[{"name":"java","slug":"java","permalink":"http://mrhe.top/categories/java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/tags/java8/"}]},{"title":"工作中一次触发器的使用","slug":"工作中一次触发器的使用","date":"2018-01-06T12:00:00.000Z","updated":"2018-01-12T10:28:22.214Z","comments":true,"path":"2018/01/06/工作中一次触发器的使用/","link":"","permalink":"http://mrhe.top/2018/01/06/工作中一次触发器的使用/","excerpt":"","text":"需求 本周五要下班的时候，客服那边突然提出了一个紧急问题，一个用户，因为最近家里面和老婆闹矛盾，正巧在我们平台投了一些私房钱，所以这段时间就不想收到平台发给她的回款短信，担心他老婆知道了，马上就周末了，毕竟又是特例，就不想在代码里面去做修改，所以就想到了触发器，我们服务器使用的是mysql，思路就是向数据库插入短信队列消息的时候，判断是不是这个客户的手机号，如果是就将短信状态置为一个不被队列扫描的状态， 实现 具体代码如下123456789CREATE TRIGGER triggerNameBEFORE INSERT ON tableNameFOR EACH ROWBEGIN if (NEW.phone=&apos;xxx&apos;) THEN set NEW.deal_flag=1 ; end if;END 在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表 触发器应该响应的动作（ DELETE、INSERT 或UPDATE） 触发器何时执行（处理之前或之后）。","categories":[{"name":"工作","slug":"工作","permalink":"http://mrhe.top/categories/工作/"}],"tags":[{"name":"触发器","slug":"触发器","permalink":"http://mrhe.top/tags/触发器/"},{"name":"工作","slug":"工作","permalink":"http://mrhe.top/tags/工作/"}]},{"title":"java8默认方法","slug":"java8默认方法","date":"2018-01-06T01:30:00.000Z","updated":"2019-02-27T02:19:28.718Z","comments":true,"path":"2018/01/06/java8默认方法/","link":"","permalink":"http://mrhe.top/2018/01/06/java8默认方法/","excerpt":"","text":"什么是默认方法java8以前，接口中所有的方法必须为抽象方法，java8允许接口在声明方法的同时提供实现，通过两种方式可以完成这种操作 接口内申明\b静态方法 \b为接口引用方法提供一个默认的实现 意思就是，你可以为接口提供具体的实现 为什么引入默认方法在以往，为接口添加方法会引发很多的改动，因为你的接口可能已经有了很多的实现类，为接口添加方法，所有的实现类都要实现它，显然是不能被接受的，但是默认方法的引入为接口的功能扩展提供了一个平滑的过度，如果你是一个类库的设计者，那么你可以放心的改进应用程序接口，无需担心遗留代码的影响 如何实现默认方法是由default修饰，并像类中声明的其它方法一样具有方法体，例如123456public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125; &#125; 那么所有继承Sized类都会默认继承了isEmpty方法，而不用去实现它，如果想扩展该方法，可以重写它 行为多继承默认方法的引入，让java8可以实现行为的多继承，这是以前无法想象的事情，它让类具有可以从多个来源重用代码的能力 继承不应该成为你一谈到代码复用就试图倚靠的万精油。比如，从一个拥有100个方法及 字段的类进行继承就不是个好主意，因为这其实会引入不必要的复杂性。你完全可以使用代理 有效地规避这种窘境，即创建一个方法通过该类的成员变量直接调用该类的方法。这就是为什 么有的时候我们发现有些类被刻意地声明为final类型:声明为final的类不能被其他的类继 承，避免发生这样的反模式，防止核心代码的功能被污染。注意，有的时候声明为final的类 都会有其不同的原因，比如，String类被声明为final，因为我们不希望有人对这样的核心 功能产生干扰。这种思想同样也适用于使用默认方法的接口。通过精简的接口，你能获得最有效的组合，因为你可以只选择你需要的实现。 解决冲突规则随着默认方法的引入，现在有可能一个类实现了多个接口，它们具有相同的函数签名，例如1234567891011121314public interface A &#123; default void hello() &#123; System.out.println(&quot;Hello from A&quot;); &#125;&#125;public interface B extends A &#123; default void hello() &#123; System.out.println(&quot;Hello from B&quot;);&#125; &#125;public class C implements B, A &#123; public static void main(String... args) &#123; new C().hello(); &#125;&#125; 这种情况类会使用哪一个方法呢，这个问题其实就是菱形继承的问题，一个类同时具有相同函数签名的方法，到底选择哪一种实现，java8为了解决这种问题引入了三条规则 类中的方法优先级最高。类或父类声明的方法优先级高于任何声明默认方法的优先级。 如果无法依据第一条进行判断，那么子接口的优先级更高，函数签名相同时，\b优先选择拥有具体实现的默认方法接口，如果B继承了A，那么B就比A更具体。 如果上述两条规则还是无法判断，继承了多个接口的类必须通过显示覆盖和调用期望方法，显式的选择使用哪一个默认方法实现。 根据这三条规则，上面的例子可以对照第二条规则，因为B继承了所以B更具体，那么结果打印出来就是Hello From B java8中接口与抽像类的区别现在java8中接口可以有具体的方法，那么他们之间的区别还有哪些 一个类只能继承一个抽象类，但是一个类可以继承多个接口 一个抽象类可以通过实例变量保存一个通用的状态，但是接口不能","categories":[{"name":"java","slug":"java","permalink":"http://mrhe.top/categories/java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/tags/java8/"}]},{"title":"next主题美化","slug":"Next主题美化","date":"2018-01-01T12:08:00.000Z","updated":"2018-01-16T08:40:49.000Z","comments":true,"path":"2018/01/01/Next主题美化/","link":"","permalink":"http://mrhe.top/2018/01/01/Next主题美化/","excerpt":"","text":"修改背景如果觉得next默认主题的背景颜色太单调，可以自己手动去替换,将下段内容12345body &#123; background:url(/images/background-1.jpeg); background-attachment: fixed;&#125; 粘贴到themes/next/source/css/_custom/custom.styl下面，不需要直接去修改系统文件，next支持用户自主扩展 添加搜索当前主题为next5.1.3版本，选择algolia做为站内搜索安装教程可以参考官方文档需要注意的是，按照文档完成之后，可以在algolia网站进行测试但是不管是搜索title，还是tag都搜索不到任何信息，经过多次测试发现默认是按着name匹配可以在下图处添加匹配字段而且可以调整匹配顺序，最终测试可以搜索到 首页文章显示预览themes-&gt;next目录下，打开配置文件_config.yml搜索auto_excerpt，将下列内容123auto_excerpt: enable: true length: 150 enable的值改为false即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/tags/Hexo/"}]},{"title":"一. Hexo+github博客搭建","slug":"Hexo博客搭建","date":"2017-12-31T07:12:33.000Z","updated":"2018-01-16T08:40:42.961Z","comments":true,"path":"2017/12/31/Hexo博客搭建/","link":"","permalink":"http://mrhe.top/2017/12/31/Hexo博客搭建/","excerpt":"","text":"工具准备安装git点击下载最新版本的git 安装Node.jsHexo是基于nodeJS环境的静态博客，所以需要下载nodejs，点击下载，然后一直安装，安装完成后可以通过node -v查看当前版本，检查是否安装成功 安装hexo现在本地新建一个文件夹，后面用来存放所有的blog的内容 cd到该目录下 通过npm i -g hexo安装hexo 安装完成之后通过hexo -v查看当前版本 初始化命令hexo init,初始化完成后会在当前目录下生成以下文件 node_modules:依赖包 public：存放生成的页面 scaffolds：命令生成文档等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需要模块配置信息 链接到github创建github账户 点击去github创建一个账户，如果有登录进去 创建一个repository 仓库名字yourname与账户名最好一致，不然后面可能会导致页面css内容无法展示 回到本地gitbash中，配置账户信息命令行输入12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 创建ssh在gitbash中输入1ssh-keygen -t rsa -C &quot;youremail&quot; 生成ssh文件，mac和linux用户在~/ssh下找到id_rsa.pub，复制文件里面内容 将生成的内容粘贴到github 点击下图箭头setting 点击左侧菜单下图箭头指向栏目 点击右上角 将本机id_rsa.pub内容粘贴到key里面 检验是否添加成功，本地gitbash中输入1git -T git@github.com 配置本地blog更改配置文件用编辑器打开hexo init目录下的_config.yml配置文件repo为github上新建的项目地址 注意所有的类型名称冒号后面一定要有空格 预览本地bloghexo3.0把服务器独立成个别模块，需要单独安装1npm i hexo-server 然后执行以下命令清除本地项目缓存1hexo clean 生成最新项目1hexo generate(缩写 hexo g) 启动hexo server1hexo server 如果上述步奏全部正确，打开浏览器输入localhost:4000，就可以看到本地项目预览了 上传到github要想blog被其他人也能访问到,就要上传到*githubgitbash中执行1npm install hexo-deployer-git --save 按着下列步骤将本地项目上传到*github123hexo cleanhexo generatehexo server 访问bloggithub中打开blog项目，点击setting下列箭头指向的即为blog访问地址 至此大功告成","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/tags/Hexo/"}]},{"title":"制作一个基于集成java和tomcat的docker镜像","slug":"新建一个docker镜像","date":"2017-12-11T16:00:00.000Z","updated":"2018-01-16T08:44:10.399Z","comments":true,"path":"2017/12/12/新建一个docker镜像/","link":"","permalink":"http://mrhe.top/2017/12/12/新建一个docker镜像/","excerpt":"","text":"根据当前所处平台安装docker准备安装java，tomcat需要的安装包制作镜像编写DockerFile构建DockerFile1docker build -t java7_tomcat7:v1 . java7_tomcat7：构建后镜像名字 v1：构建后的镜像tag .：当前路径 查看镜像构建成功以后可以通过1docker images 查看构建成功后的镜像 启动容器输出一个Hello World之后终止容器1sudo docker run ubuntu:14.04 /bin/echo &apos;Hello World&apos; 启动一个bash终端允许用户交互1sudo docker run -t -i ubuntu:14.0.4 /bin/bash 其中-t表示让Docker分配一个伪终端并绑定在标准输入,-i则表示标准输入保持打开 1sudo docker run -t -i -p 9999:8080 ubuntu:14.0.4 /bin/bash -p后面的端口，表示将宿主机器的9999端口绑定到容器的8080端口，可以通过宿主机器ip+9999端口，访问容器内的服务。 进入正在运行的容器1docker attach 44fc0f0582d9 后面的字符串为容器id可以通过1docker ps 查看正在运行的容器1docker ps -a 查看所有的容器 为镜像打标签1docker tag vpjr:v1 clysheng/vpjr:v1 vpjr:v1本地镜像名字和tag名字clysheng/vpjr:v1 :修改后的名字 上传镜像到dockerhub1docker push clysheng/vpjr:v1 可以先通过1docker login 登录","categories":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/tags/docker/"}]}]}