{"meta":{"title":"Harvey's blog","subtitle":"无论工作多忙，计划都要坚持","description":"再牛逼的梦想，也抵不过傻逼式的坚持","author":"Harvey","url":"http://mrhe.top"},"pages":[{"title":"categories","date":"2017-12-31T07:29:31.000Z","updated":"2017-12-31T07:50:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://mrhe.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-31T07:29:14.000Z","updated":"2017-12-31T07:42:09.473Z","comments":true,"path":"tags/index.html","permalink":"http://mrhe.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何阅读一本书","slug":"如何阅读一本书","date":"2018-01-10T13:00:00.000Z","updated":"2018-01-12T10:24:14.000Z","comments":true,"path":"2018/01/10/如何阅读一本书/","link":"","permalink":"http://mrhe.top/2018/01/10/如何阅读一本书/","excerpt":"","text":"读书的四层境界 基础阅读快速浏览，不管能不能读懂，知道在说什么就行 检视阅读用最少的时间了解书在说什么，书的结构，包含部分，分类，以及作者意图分为两种： 有系统的略读或粗读最少的时间找到这本书的主题或思想线索，包括书名，标题，序言，目录，索引，然后从目录里挑选一些跟主题息息相关的章节来看，然后打开书随便看一下，或者挑一些阅读下 粗浅的阅读重点在于不停顿，哪怕读到看不懂的地方也不要停下来查资料，直接忽略掉，重点放在自己能看懂的地方，哪怕最终只读懂了书里面一小部分，但是没有关系，起码已经读懂了这些，享受阅读的乐趣是学会的前提 分析阅读把一本书看透，嚼烂和消化书中内容 主题阅读读的不是书而是主题，同时阅读某个主题的多本书 阅读的时候要提出四个基本的问题 整体来看这本书在说什么 作者细节上说了什么 说的有道理吗，是部分还是全部 这本书和你有关系吗 分析阅读分\b类阅读之前一定要知道自己在读的是哪一类书，学会如何分类，可以简单把书分为小说类和论说类，或者理论性作品刚和实用型作品 \b\b透视一本书 寻找书的骨架 使用\b单一的句子，或最多几句话来叙述整本书的内容 将书中重要的篇章列举出来，并能说明他们是如何按照一定的顺序组成一个架构的 找出作者要问的问题或者要解决的问题 找出重要的单字，并透过他们与作者达成共识 将一本书重要的句子圈出来，找出其中主旨 从相关的关联中，设法架构出一本书的基础论述 找出作者解答 在评论之前一定能肯定的说我了解了 不同意作者观点要理性表达自己意见，不辩驳，不争论 尊重知识和个人观点，做任何判断前，要找到理论依据 如何阅读各种类型书籍如何阅读实用型书 检查作者是否提出了合理可执行，并且效果可检查的方法是分辨是否是实用类书籍的一个方法。 实际问题只能靠行动来解决，看完不行动，那看的就是鸡汤 如何阅读想象文学 不要抗拒想象文学带给你的影响力 不要去找共识，主旨和论述 如何阅读故事书(小说) 快速并且全心全意的读 不要太在意暂时的障碍，继续读下去，自然会柳暗花明 如何阅读史书和戏剧 主动，集中注意力的阅读 \b运用更多的想象力 最好一口气读完 如何阅读抒情诗 一口气读完 重复，大声读出来 了解一首诗最好的方式就是一遍遍的去读它","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://mrhe.top/tags/读书笔记/"}]},{"title":"Optional","slug":"java8 Optional.1","date":"2018-01-09T01:30:00.000Z","updated":"2018-01-12T10:28:11.050Z","comments":true,"path":"2018/01/09/java8 Optional.1/","link":"","permalink":"http://mrhe.top/2018/01/09/java8 Optional.1/","excerpt":"","text":"null引发的问题null最常见带来的问题就是NullPointerException，即使在我们认为可能出现null的地方加上if语句判断，任然会频发的和它打交道，而且还会代码出现很多的if嵌套，被它的概念提出者Tony Hoare称之为价值百万的失误 Optional的作用能非常清晰地界定出变量值的缺失是结构上的问题，还是你算法上的缺陷，抑或是你数据中的问题。另外，我们还想特别强调，引入Optional 类的意图并非要消除每一个null引用。与此相反，它的目标是帮助你更好地设计出普适的API， 让程序员看到方法签名，就能了解它是否接受一个Optional的值。这种强制会让你更积极地将 变量从Optional中解包出来，直面缺失的变量值。 如何使用创建Optional对象声明一个空的Optional1Optional&lt;Car&gt; car = Optional.empty() ; 依据一个非空值创建Optional12Car car = null ;Optional&lt;Car&gt; carOpt = Optional.of(car) ; 如果car是一个空值，这段代码会立即抛出NullPointerException，而不是等到试图访问car属性的时候 可接受null的Optional12Car car = null ;Optional&lt;Car&gt; carOpt = Optional.ofNullable(car) ; 如果car是空那么carOpt就是一个空对象，获取对象中的值的时候依然会抛出异常 一点注意Optional在设计的时候没有考虑做为类的字段使用，所以它\b并未实现序列化接口，所以某些要求序列的库或框架中使用Optional有可能会引发应用故障\b 常用API 方法 描述 empty 返回一个空的 Optional 实例 flatMap 如果值存在，就对该值执行提供的 mapping 函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象 get 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常 ifPresent 如果值存在，就执行使用该值的方法调用，否则什么也不做 isPresent 如果值存在就返回 true，否则返回 false map 如果值存在，就对该值执行提供的 mapping 函数调用 of 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常 ofNullable 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象 orElse 如果有值则将其返回，否则返回一个默认值 orElseGet 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 orElseThrow 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 实战例子返回一个正整数，如果小于0或者不存在则返回0123456789101112131415Properties properties = new Properties() ;properties.put(&quot;a&quot;,1) ;properties.put(&quot;b&quot;,-5) ;properties.put(&quot;c&quot;,1) ; public int getValueOptional(Properties properties,String name)&#123; return Optional.ofNullable(properties.getProperty(name)).flatMap(OptionalTest::stringToInt).filter(i -&gt; i&gt;0).orElse(0) ;&#125;public static Optional&lt;Integer&gt; stringToInt(String s) &#123; try &#123; return Optional.of(Integer.parseInt(s)); &#125; catch (NumberFormatException e) &#123; return Optional.empty(); &#125;&#125; 通过这个例子可以看出，Optional加入丰富了\b\b语意，减少了之前很多不必要的if判断，代码更简洁直观","categories":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/categories/java8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/tags/java8/"},{"name":"Optional","slug":"Optional","permalink":"http://mrhe.top/tags/Optional/"}]},{"title":"工作中一次触发器的使用","slug":"工作中一次触发器的使用","date":"2018-01-06T12:00:00.000Z","updated":"2018-01-12T10:28:22.214Z","comments":true,"path":"2018/01/06/工作中一次触发器的使用/","link":"","permalink":"http://mrhe.top/2018/01/06/工作中一次触发器的使用/","excerpt":"","text":"需求 本周五要下班的时候，客服那边突然提出了一个紧急问题，一个用户，因为最近家里面和老婆闹矛盾，正巧在我们平台投了一些私房钱，所以这段时间就不想收到平台发给她的回款短信，担心他老婆知道了，马上就周末了，毕竟又是特例，就不想在代码里面去做修改，所以就想到了触发器，我们服务器使用的是mysql，思路就是向数据库插入短信队列消息的时候，判断是不是这个客户的手机号，如果是就将短信状态置为一个不被队列扫描的状态， 实现 具体代码如下123456789CREATE TRIGGER triggerNameBEFORE INSERT ON tableNameFOR EACH ROWBEGIN if (NEW.phone=&apos;xxx&apos;) THEN set NEW.deal_flag=1 ; end if;END 在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表 触发器应该响应的动作（ DELETE、INSERT 或UPDATE） 触发器何时执行（处理之前或之后）。","categories":[{"name":"工作","slug":"工作","permalink":"http://mrhe.top/categories/工作/"}],"tags":[{"name":"触发器","slug":"触发器","permalink":"http://mrhe.top/tags/触发器/"},{"name":"工作","slug":"工作","permalink":"http://mrhe.top/tags/工作/"}]},{"title":"java8默认方法","slug":"java8默认方法","date":"2018-01-06T01:30:00.000Z","updated":"2018-01-12T10:28:14.254Z","comments":true,"path":"2018/01/06/java8默认方法/","link":"","permalink":"http://mrhe.top/2018/01/06/java8默认方法/","excerpt":"","text":"什么是默认方法java8以前，接口中所有的方法必须为抽象方法，java8允许接口在声明方法的同时提供实现，通过两种方式可以完成这种操作 接口内申明\b静态方法 \b为接口引用方法提供一个默认的实现 意思就是，你可以为接口提供具体的实现 为什么引入默认方法在以往，为接口添加方法会引发很多的改动，因为你的接口可能已经有了很多的实现类，为接口添加方法，所有的实现类都要实现它，显然是不能被接受的，但是默认方法的引入为接口的功能扩展提供了一个平滑的过度，如果你是一个类库的设计者，那么你可以放心的改进应用程序接口，无需担心遗留代码的影响 如何实现默认方法是由default修饰，并像类中声明的其它方法一样具有方法体，例如123456public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125; &#125; 那么所有继承Sized类都会默认继承了isEmpty方法，而不用去实现它，如果想扩展该方法，可以重写它 行为多继承默认方法的引入，让java8可以实现行为的多继承，这是以前无法想象的事情，它让类具有可以从多个来源重用代码的能力 继承不应该成为你一谈到代码复用就试图倚靠的万精油。比如，从一个拥有100个方法及 字段的类进行继承就不是个好主意，因为这其实会引入不必要的复杂性。你完全可以使用代理 有效地规避这种窘境，即创建一个方法通过该类的成员变量直接调用该类的方法。这就是为什 么有的时候我们发现有些类被刻意地声明为final类型:声明为final的类不能被其他的类继 承，避免发生这样的反模式，防止核心代码的功能被污染。注意，有的时候声明为final的类 都会有其不同的原因，比如，String类被声明为final，因为我们不希望有人对这样的核心 功能产生干扰。这种思想同样也适用于使用默认方法的接口。通过精简的接口，你能获得最有效的组合，因为你可以只选择你需要的实现。 解决冲突规则随着默认方法的引入，现在有可能一个类实现了多个接口，它们具有相同的函数签名，例如1234567891011121314public interface A &#123; default void hello() &#123; System.out.println(&quot;Hello from A&quot;); &#125;&#125;public interface B extends A &#123; default void hello() &#123; System.out.println(&quot;Hello from B&quot;);&#125; &#125;public class C implements B, A &#123; public static void main(String... args) &#123; new C().hello(); &#125;&#125; 这种情况类会使用哪一个方法呢，这个问题其实就是菱形继承的问题，一个类同时具有相同函数签名的方法，到底选择哪一种实现，java8为了解决这种问题引入了三条规则 类中的方法优先级最高。类或父类声明的方法优先级高于任何声明默认方法的优先级。 如果无法依据第一条进行判断，那么子接口的优先级更高，函数签名相同时，\b优先选择拥有具体实现的默认方法接口，如果B继承了A，那么B就比A更具体。 如果上述两条规则还是无法判断，继承了多个接口的类必须通过显示覆盖和调用期望方法，显式的选择使用哪一个默认方法实现。 根据这三条规则，上面的例子可以对照第二条规则，因为B继承了所以B更具体，那么结果打印出来就是Hello From B java8中接口与抽像类的区别现在java8中接口可以有具体的方法，那么他们之间的区别还有哪些 一个类只能继承一个抽象类，但是一个类可以继承多个接口 一个抽象类可以通过实例变量保存一个通用的状态，但是接口不能","categories":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/categories/java8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://mrhe.top/tags/java8/"},{"name":"默认方法","slug":"默认方法","permalink":"http://mrhe.top/tags/默认方法/"}]},{"title":"next主题美化","slug":"Next主题美化","date":"2018-01-01T12:08:00.000Z","updated":"2018-01-12T10:28:17.439Z","comments":true,"path":"2018/01/01/Next主题美化/","link":"","permalink":"http://mrhe.top/2018/01/01/Next主题美化/","excerpt":"","text":"修改背景如果觉得next默认主题的背景颜色太单调，可以自己手动去替换,将下段内容12345body &#123; background:url(/images/background-1.jpeg); background-attachment: fixed;&#125; 粘贴到themes/next/source/css/_custom/custom.styl下面，不需要直接去修改系统文件，next支持用户自主扩展 添加搜索当前主题为next5.1.3版本，选择algolia做为站内搜索安装教程可以参考官方文档需要注意的是，按照文档完成之后，可以在algolia网站进行测试但是不管是搜索title，还是tag都搜索不到任何信息，经过多次测试发现默认是按着name匹配可以在下图处添加匹配字段而且可以调整匹配顺序，最终测试可以搜索到 首页文章显示预览themes-&gt;next目录下，打开配置文件_config.yml搜索auto_excerpt，将下列内容123auto_excerpt: enable: true length: 150 enable的值改为false即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/tags/Hexo/"}]},{"title":"2018计划清单","slug":"2018计划清单","date":"2018-01-01T07:00:00.000Z","updated":"2018-01-12T09:53:53.094Z","comments":true,"path":"2018/01/01/2018计划清单/","link":"","permalink":"http://mrhe.top/2018/01/01/2018计划清单/","excerpt":"","text":"坚持运动以周为单位，每周至少保持运动三次，跑步，羽毛球，篮球，爬山都算每天早起坚持做至少二十个俯卧撑或者至少40个深蹲，数量少，贵在养成坚持的习惯每三个月跑一个十公里 坚持背单词完成百词斩计划，每天新记10个单词每周读懂一篇英语短文每个月记下一篇英语短文 书单下面书籍为2018年想学习的书籍，每天至少保证工作时间外抽出时间学习一个小时 书名 计划完成时间 掌握情况 java8实战 2018-02-10 spring-boot实战 2018-03-10 netty权威指南 2018-05-10 docker 2018-06-10 kafka 2018-06-10 高性能mysql 2018-08-10 spring-cloud 大型网站技术架构 深入理解jm Effective Java 算法导论 把时间当做朋友 除了上述书籍外，想增强的技术还有redis，ngnix抽空看博客学习 关于日常重要的物品养成放在指定地方的习惯，避免日常花费多余的时间找东西养成早起的习惯，工作日六点起床，周末8点前起床的无论工作多忙提醒自己，每天上午下午至少一杯水学会炒菜，目标每两个月会一道菜家里卫生每周至少一次 坚持写博客养成写作的习惯，每个星期至少更新一篇博客，内容形式不限制，可以是技术学习笔记，也可以是生活感悟，也可以是喜欢内容摘抄，通过写作让自己变的不浮躁，养成思考的习惯","categories":[{"name":"计划","slug":"计划","permalink":"http://mrhe.top/categories/计划/"}],"tags":[{"name":"计划","slug":"计划","permalink":"http://mrhe.top/tags/计划/"}]},{"title":"一. Hexo+github博客搭建","slug":"Hexo博客搭建","date":"2017-12-31T07:12:33.000Z","updated":"2018-01-12T09:55:22.000Z","comments":true,"path":"2017/12/31/Hexo博客搭建/","link":"","permalink":"http://mrhe.top/2017/12/31/Hexo博客搭建/","excerpt":"","text":"工具准备安装git点击下载最新版本的git 安装Node.jsHexo是基于nodeJS环境的静态博客，所以需要下载nodejs，点击下载，然后一直安装，安装完成后可以通过node -v查看当前版本，检查是否安装成功 安装hexo现在本地新建一个文件夹，后面用来存放所有的blog的内容 cd到该目录下 通过npm i -g hexo安装hexo 安装完成之后通过hexo -v查看当前版本 初始化命令hexo init,初始化完成后会在当前目录下生成以下文件 node_modules:依赖包 public：存放生成的页面 scaffolds：命令生成文档等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需要模块配置信息 链接到github创建github账户 点击去github创建一个账户，如果有登录进去 创建一个repository 仓库名字yourname与账户名最好一致，不然后面可能会导致页面css内容无法展示 回到本地gitbash中，配置账户信息命令行输入12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 创建ssh在gitbash中输入1ssh-keygen -t rsa -C &quot;youremail&quot; 生成ssh文件，mac和linux用户在~/ssh下找到id_rsa.pub，复制文件里面内容 将生成的内容粘贴到github 点击下图箭头setting 点击左侧菜单下图箭头指向栏目 点击右上角 将本机id_rsa.pub内容粘贴到key里面 检验是否添加成功，本地gitbash中输入1git -T git@github.com 配置本地blog更改配置文件用编辑器打开hexo init目录下的_config.yml配置文件repo为github上新建的项目地址 注意所有的类型名称冒号后面一定要有空格 预览本地bloghexo3.0把服务器独立成个别模块，需要单独安装1npm i hexo-server 然后执行以下命令清除本地项目缓存1hexo clean 生成最新项目1hexo generate(缩写 hexo g) 启动hexo server1hexo server 如果上述步奏全部正确，打开浏览器输入localhost:4000，就可以看到本地项目预览了 上传到github要想blog被其他人也能访问到,就要上传到*githubgitbash中执行1npm install hexo-deployer-git --save 按着下列步骤将本地项目上传到*github123hexo cleanhexo generatehexo server 访问bloggithub中打开blog项目，点击setting下列箭头指向的即为blog访问地址 至此大功告成","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://mrhe.top/tags/Hexo/"}]},{"title":"制作一个基于集成java和tomcat的docker镜像","slug":"新建一个docker镜像","date":"2017-12-11T16:00:00.000Z","updated":"2018-01-12T10:28:25.000Z","comments":true,"path":"2017/12/12/新建一个docker镜像/","link":"","permalink":"http://mrhe.top/2017/12/12/新建一个docker镜像/","excerpt":"","text":"根据当前所处平台安装docker准备安装java，tomcat需要的安装包制作镜像编写DockerFile构建DockerFile1docker build -t java7_tomcat7:v1 . java7_tomcat7：构建后镜像名字 v1：构建后的镜像tag .：当前路径 查看镜像构建成功以后可以通过1docker images 查看构建成功后的镜像 启动容器输出一个Hello World之后终止容器1sudo docker run ubuntu:14.04 /bin/echo &apos;Hello World&apos; 启动一个bash终端允许用户交互1sudo docker run -t -i ubuntu:14.0.4 /bin/bash 其中-t表示让Docker分配一个伪终端并绑定在标准输入,-i则表示标准输入保持打开 1sudo docker run -t -i -p 9999:8080 ubuntu:14.0.4 /bin/bash -p后面的端口，表示将宿主机器的9999端口绑定到容器的8080端口，可以通过宿主机器ip+9999端口，访问容器内的服务。 进入正在运行的容器1docker attach 44fc0f0582d9 后面的字符串为容器id可以通过1docker ps 查看正在运行的容器1docker ps -a 查看所有的容器 为镜像打标签1docker tag vpjr:v1 clysheng/vpjr:v1 vpjr:v1本地镜像名字和tag名字clysheng/vpjr:v1 :修改后的名字 上传镜像到dockerhub1docker push clysheng/vpjr:v1 可以先通过1docker login 登录","categories":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://mrhe.top/tags/docker/"}]}]}